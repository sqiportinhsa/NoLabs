# Cравнение сортировок

## Пункт 1. Cортировка вставками, пузырьком, выбором (2 б).
> Напишите сортировки вставками, пузырьком, выбором.
> Запускаем тест для массивов размера от 1000 до 1000000 с шагом 10000.
> Для каждого размера гененрируем массив, и сортируем, засечь время работы сортировки.
> *Все три сортировки тестим на одинаковых массивах*
> Для кажого размера и каждой сортировки делаем 5 тестов и усредняем итог.
> Построить график для каждой сортировки(из 100 точек). 
>
> Советую строить с помощью python.
> https://pythonru.com/biblioteki/pyplot-uroki?ysclid=le6cok2zm0349935651 
>
> Какая в итоге отработала лучше?

Результаты сравнения квадратичных сортировок без оптимизации следующие:

![quadratic](plots/images/quadratic.png)
![quadratic_linearization](plots/images/quadratic_linearization.png)

Как видно из графиков, сортировки имеют одинаковую (квадратичную) асимптотику с разными константами. Пузырьковая сортировка проигрывает сортировке вставками, они обе заметно проигрывают сортировке выбором. Почему так получается? На константу влияет количество операций, произведенных на каждом шаге между рекурсивными вызовами, в частности количество перестановок элементов местами. Пузырьковая сортировка проходит по ещё не отсортированной части массива, производя обмен элементов, если он требуется, а значит для случайного массива примерно половина сравнений окончится перестановкой. Сортировка вставками наоборот проходит по уже отсортированной части массива, производя обмены, пока элемент не окажется на своем месте, таким образом для случайного массива потребуется переставить примерно половину уже отсортированных значений. Сортировка выбором в отличие от двух других не требует такого большого количества перестановок, на каждой иттерации производя обмен первого элемента не на своем месте с элементом, который должен стоять на месте рассматриваемого. Таким образом за счет меньшего количества обменов уменьшается константа.

Попробуем произвести оптимизации. Для того, чтобы вставить элемент в insertion sort требуется менять местами все большие уже отсортированные элементы. При этом каждый обмен требует вызова функции и изменения значений в двух ячейках массива. Чтобы уменьшить количество операций, можно сразу ставть каждый элемент на свое место, то есть на каждом шаге изменять не две, а одну ячейку массива. Для этого сдвинем каждый элемент на один вправо, проходясь справа налево и заменяя значение в ячейке на стоящее слева от него. После этого в освободившуюся левую ячейку можно вставить самый правый элемент, то есть как раз тот, который нужно было. Таким образом мы сокращаем количество обменов на каждом шаге в два раза. 

Дополнительно можно воспользоваться знанием об упорядоченности префикса массива, находя место для вставки элемента при помощи бин. поиска, это позволит искать его за логарифмическое по размеру отсортированной части время вместо линейного.

На следующем графике предствлено сравнение сортировки вставками без оптимизаций с сортировкой вставками со сдвигом части массива и со сдвигом и использованием бинпоиска:

![insertion_optimizations](plots/images/insertion_opt.png)

Мы видим, что использование оптимизаций действительно ускоряет работу. При этом разница от добавления бинпоиска видна не так сильно как при улучшении обмена элементов из-за того, что поиск занимает меньшую долю времени от всей сортировки из-за того, что только сравнивает и не пишет в память, а значит его улучшение слабее повлияет на общее улучшение программы.

Сравним теперь оптимизированную сортировку вставками с сортировкой выбором:

![insertion_vs_selection](plots/images/insertion_vs_selection.png)

Благодаря оптимизации сортировки почти сравнялись. При этом сортировка выбором выигрывает за счет константного количества сравнений и проигрывает за счет линейного по размеру неотсортированной части поиска подходящего элемента, а сортировка вставками выигрывает за счет логарифмического по размеру отсортированной части поиска места для вставки и проигрывает за счет линейного по размеру отсортированной части количества перестановок. Выбор конкретной сортировки в данном случае зависит от констант, связанных со временем сравнения и перестановки элементов массива, потому как в случае быстрого сравнения и долгой перестановки преимущество будет иметь сортировка выбором, способная быстро переставлять, а в обратном случае выиграет сортировка вставками, способная быстро искать.

## Пункт 2. Быстрая сортировка  (3 б. + 2 бонус).
> Делаем то же самое(такие же тесты, только теперь размеры до 10 млн, но шаг 100000.), используем разные стратегии выбора опорного эелемента:
> *Сортировка и первые три пункта - это 3 б.*
> * медиана 3х 
> * центральный 
> * случайный 
> * медиана медиан (+2б)
>
> Какая стратегия оптимальна?

Тестирование на случайных массивах как в условии показывает следюущие результаты:

![qsort](plots/images/qsort.png)

Проанализируем дополнительно случаи уже отсортрованного в прямом и обратном порядке массива и массива из одинаковых элементов. Сравнение сортировок в этих случаях:

![qsort_rand_a](plots/images/qsort_rand_arr.png)
![qsort_rev](plots/images/qsort_rev.png)
![qsort_sort](plots/images/qsort_sorted.png)
![qsort_id](plots/images/qsort_eq.png)

Так же посмотрим на работу каждой сортировки в различных ситуациях:

![qsort_rand_p](plots/images/qsort_rand_pivot.png)
![qsort_cent](plots/images/qsort_cent_pivot.png)
![qsort_med](plots/images/qsort_med_pivot.png)

Случайный элемент всегда отрабатывает хуже, вне зависимости от ситуации, вероятно из-за временных затрат на генерацию случайного числа. В остальном все три варианта отрабатывают примерно одинаково во всех случаях. Так же хочется отметить, что при наличии здесь способа выбора опопрного элемента как первого или последнего (к чему автор был близок при написании контеста) сортировка работала бы медленне, вырождаясь в квадратичную и на массиве одинаковых элементов и на отсортированном массиве в силу того, что на каждом шаге отсекался бы всего один элемент. Здесь же для уже отсортированного массива и для массива одинаковых элементов выбор цинтрального и медианного опорных элементов делит массив почти идеально пополам, а значит сортировка работает идеально в соответствии с асимптотикой. Ухудшить время можно, например, для сортировки с выбором среднего элемента в качестве опорного, положив на будущие места опорных элементов максимальные возможные так, чтобы при каждом разделении происходило отсечение всего одного элемента. Получаются такие результаты:

![qsort_antimed](plots/images/qsort_antimed.png)

Здесь видно, что в отличие от остальных ситуаций, когда медиана трех и центр давали почти одинаковые результаты, работа сортировки с выбором центрального элемента в качестве опорного ухудшилась.

## Пункт 3. Сортировка слиянием (2 б).
> Добавить сортировку слиянием(такие же тесты, только теперь размеры до 10 млн, но шаг 100000).

Тестирование выдает следующие результаты:

![merge](plots/images/merge.png)

Попробуем оптимизировать классический вариант. Заметим, что сортировка слиянием рекурсивная, а значит её вызов на массивах маленького размера производится часто и тратит значительное время на вызов функции. Вспомним, что квадратичные сортировки устроены проще и не требуют рекурсии, а значит лишены такой значительной потери времени на маленьких подмассивах. Попробуем переключаться на insertion sort при достижении некоторого критического минимального размера массива и подберем оптимальный такой размер. Для этого проведем измерения времени для разных критических значений, в данном случае это массив [0, 5, 10, 25, 50, 75, 100]. Результаты предствалены на следующих графиках:

![merge_with_0](plots/images/merge_opt.png)
![merge_without_0](plots/images/merge_opt2.png)

На первом графике можно увидеть, как сильно сортировка без использования переключения на сортировку вставками отстает от остальных, на втором представлены те же значение, но сортировка без переключения не отрисована ради масштаба. Среди всех лидирует вариант с переключением на 10 элементах, однако для небольших размеров линии достаточно близко, что портит наглядность. Поэтому построим графики зависимости времени исполнения от критического размера для различных размеров массивов:

![merge_all_sizes](plots/images/merge_opt3.png)

Так же рассмотрим все значения отдельно:

![merge2](plots/images/merge2.png)
![merge4](plots/images/merge4.png)
![merge6](plots/images/merge6.png)
![merge8](plots/images/merge8.png)

Таким образом явным лидером становится вариант с критическим размером, равным 10: он и получает преимущества от уменьшения количества рекурсивных вызовов, и не теряет время за счет использования сортировки с квадратичной асимптотикой на больших подмассивах.


## Пункт 4. Цифровая сортировка(LSD + MSD*) (3 б. + 4 бонус).
> * Добавить цифровую сортировку(LSD) для uint32_y (такие же тесты, только теперь размеры до 10 млн, но шаг 100000).
> * Добавить MSD сортировку для uint32_y (такие же тесты, только теперь размеры до 10 млн). (+2б), что в итоге лучше для чиселок сработало?
> * Добавить MSD сортировку для строк, потестить на массивах строк (+2б)
>
> Как тестить строки?
> 
> * Тест 1. Генерируем N строк длины K=1000 по буквам, все буквы равновероятны.
> * Тест 2. Генерируем N строк длины от 1 до N=1000000 по буквам, все буквы равновероятны. Случайно перемешиваем.
> 

Измерение времени показывает следующие результаты:

![lsd](plots/images/lsd.png)

Сортировка показывает линейные результаты как и должна была. Действительно, мы фиксированное количество раз (равное количеству разрядов максимального числа) сортируем массив сортировкой подстчетом, работающей за линейное по размеру массива время. Интереснее посмотреть на неё в сравнении с другими сортировками.

## Пункт 5. Выводы (1б.)
> Напишите вывод(что удивило, что узнали нового)

Сравним сортировки вместе:

![all_all](plots/images/all_with_quadr.png)

Сраза видно, что квадратичные сортировки заметно проигрывают остальным в прямом сравнении (даже самая быстрая из них selection sort), поэтому построим так же график без квадратичных сортировок:

![all_without_quadratic](plots/images/all.png)

Мы видим, что константа действительно имеет значение в случае реальных сортировок: после хорошей оптимизации merge sort не уступает линейной LSD. Асимптотики у них разные, а значит разницу можно будет почувствовать, но на гораздо больших размерах массивов. Здесь же можно сделать вывод о том, что квадратичные сортировки не так бесполезны, как кажутся, и хоть и были выкинуты с графика с большими массивами, на маленьких размерах (например на полученном нами 10) работают лучше, чем рекурсивные логарифмические сортировки. 

При всем этом сортировка LSD будет обходить остальные как на маленьких, так и на больших массивах за счет своей линейности и нерекурсивности. При этом она хороша благодрая тому, что использует информацию о том, как устроены сравниваемые данные, в нашем случае числа, а значит будет менее универсальной.

Быстрая сортировка хороша в сравнении с сортировкой слиянием возможностью выполнения на месте, то есть без требования дополнительной памяти. Однако сортировка слиянием является более предсказуемой с точки зрения времени работы так как не опирается на случайность и не требует выбора опорного элемента, который может быть как удачным, так и неудачным в зависимости от случая.