# Практическая работа 2. "Сравнение скорости работы динамического массива и односвязного списка"

> Необходимо написать динамический массив и односвязный список. 
>
> Далее необходимо написать два стека: на списке и на массиве.
>
>У стеков должны быть следующие функции:
>* `struct Stack* stack_ctr(size_t size, size_t element_size) `
Создает массив заданного размера, который потом будет изменяться в ходе исполнения (только для массива)
>* `int push(struct Stack* st, void* buffer) `
Добавляет элемент в конец контейнера, возвращает 1 если добавление успешно, 0 - не успешно
>* `int top(struct Stack* st, void* buffer) `
Возвращает последний элемент
>* `int pop(struct Stack* st)` Удаляет последний элемент, не возвращая его, возвращает 1 - если успех, 0 - если ошибка
>* `struct Stack* stack_dtr(struct Stack* st) `
Уничтожает контейнер, освобождая память, возвращает nullptr


## Произведены следующие тесты:


### Тест 1
> Надо запушить  `10^6` интов, потом удалить половину элементов и запушить четверть - останется 750000 интов. Повторять удаление половины и вставку четверти, пока не останется в стеке меньше 100000 элементов (получится 9 итераций).

Были произведены тесты и получены сделующие результаты:

| dimension | array stack  | list stack |
|-----------|--------------|------------|
| 1         |47370         |562459      |
| 2         |48442         |553835      |
| 3         |49899         |554801      |
| average   |48570         |557032      |

Время указано в микросекундах. Стек на динамическом массиве требует меньше времени на исполнение тестов чем стек на списке в 11.5 раз.

### Тест 2
> Надо запушить  `10^6` интов, потом 100 раз удалить 10000 элементов и добавить столько же. Далее как в первом тесте провести 9 итераций удаления-вставки и снова 100 раз удалить 10000 элементов и добавить столько же.

В результате запусков тестов были получены следующие результаты:

| dimension | array stack  | list stack |
|-----------|--------------|------------|
| 1         |97168         |1139220     |
| 2         |99144         |1146319     |
| 3         |97913         |1129378     |
| average   |98075         |1138305     |

Время указано в микросекундах. Стек на динамическом массиве обгоняет стек на списке в 11.6 раз.

### Тест 3
> Надо научиться средствами языка генерировать случайные числа из множества {1,2}. Далее сначала довести размер стека до миллиона, а потом выполнить миллион инструкций следующего вида: каждое выпадение единицы добавлять элемент, а на двойку - попать из стека. Засекать время после доведения размера стека до миллиона.

Тесты показали следующие результаты:

| dimension | array stack  | list stack |
|-----------|--------------|------------|
| 1         |23522         |150702      |
| 2         |24169         |150694      |
| 3         |24227         |151104      |
| average   |23972         |150833      |

Время указано в микросекундах. Время выполнения тестов для стека на списке превосходит время для стека на массиве в 6.3 раза.

## Выводы
Стек на динамическом массиве работает гораздо быстрее. Существенная разница наблюдается за счет кэширования: в случае, если последовательно используются данные массива, находящиеся в соседних ячейках, они будут загружены из памяти в кэш одновременно, а значит загрузка будет требоваться реже, что позволяет экономить на работе с памятью. В случае реализации стека на списке такое не происходит так как для перехода к следующей ячейке необходимо обращение по указателю, поэтому данная реализация работает медленнее. Тесты 1 и 2 дают больший чем тест 3 разрыв по скорости за счет того, что тратится время на генерацию команд, и работа с данными стека занимает меньшую долю времени, чем в первых двух тестах. Таким образом ускорение этой части дает больший эффект когда действия со стеком определены заранее.
