# RSQ 6 б
> * Напишите дерево Фенвика для поиска суммы на подотрезке,
> * Также напишите дерево отрезков на поиск суммы и обновление значения.
> * Постройте дерево Фенвика и ДО для случайного массива из 10^6 элементов
> * Cгенерируйте 10^6 невырожденных отрезков, тип запроса - случайный.
> 
> * Засеките время ответов на все запросы для каждого дерева. 
> * Тест повторить 5 раз и усреднить время.

| тест | Дерево Фенвика, ms | Дерево отрезков, ms |
|------|--------------------|---------------------|
| 1    | 52                 | 318                 |
| 2    | 51                 | 312                 |
| 3    | 56                 | 323                 |
| 4    | 53                 | 304                 |
| 5    | 55                 | 310                 |
| avg  | 53                 | 313                 |

Построение дерева Фенвика требует память, совпадающую с размером массива, в то время как дерево отрезков в худшем требует в 4 раза больше памяти, чем оригинальный массив. Дополнительно, дерево Фенвика реализуется нерекурсивно при помощи цикла, и на каждом шаге обрабатывает не более двух вершин. Дерево отрезков же реализовано с использованием рекурсии при обработке запроса, и на каждом шаге возможно два рекурсивных вызова. Таким образом на каждом уровне дерева производится обработка до 4х вершин. При этом за счет рекурсии эта обработка не одновременна, а значит обращение к памяти вызывает значительную задержку. Из-за рекурсивных вызовов и обработки большего количества вершин дерево отрезков замедляется в несколько раз.


# RMQ 4 б
> Реализуйте 2 варианта Sparse table
> 
> * Вариант 1 - храним log N строк по N элементов
> * Вариант 2 - храним n строк по logN элементов
> 
> * Постройте SparseTable для случайного массива из 10^6 элементов
> * Cгенерируйте 10^6 невырожденных отрезков.
> 
> * Засеките время ответов на все запросы для двух видов таблиц 
> * Тест повторить 5 раз и усреднить время.

| тест | Вариант 1, ms | Вариант 2, ms       |
|------|---------------|---------------------|
| 1    | 49            | 112                 |
| 2    | 51            | 111                 |
| 3    | 54            | 113                 |
| 4    | 50            | 114                 |
| 5    | 51            | 112                 |
| avg  | 51            | 112                 |

Вариант 1 работает быстрее за счет более оптимальной работы с памятью. В процессе работы алгоритма мы выбираем одну из строк, после чего, находясь в одном массиве выбираем два элемента. Во втором случае нам требуется взять элементы из двух различных массивов, что приводит к необходимости обращения к двум далеким друг от друга местам в памяти. Задержка из-за загрузки данных в кеш является основным фактором, замедляющим работу программы. Таким образом, вариант 1 работает в 2 раза быстрее за счет в два раза меньшего количества обращений к памяти.
